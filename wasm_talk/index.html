<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>WebAssembly</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		
		<link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed|Roboto+Mono" rel="stylesheet">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>

<body style="background: url(./img/sbarra.png) fixed no-repeat bottom left; background-color: #222; background-size: 5%;">
	<div class="reveal">
		<div class="slides">

<section>
<img src="./img/WAlogo.png" style="width:15%; background:none; border:none; box-shadow: none;">
<h1>WebAssembly</h1>
<p>Leonardo Santana</p>
<p><small><code>ls.santana@samsung.com</code></small></p>
<img src="./img/sidiacolor.png" style="width:20%; background:none; border:none; box-shadow: none;">
</section>

<section>
	<section data-markdown data-template data-separator-notes="^Note:">
		## How JavaScript works

		![How JavaScript works](img/js.png) <!-- .element: class="fragment" -->

		Note:
		Web APIs: DOM, Canvas, WebGL, Timer, WebAudio, Geolocation
	</section>

	<section data-markdown data-template data-separator-notes="^Note:">
		![How JavaScript works](img/js_animation.gif)
	</section>
</section>

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	What if I want to use my **legacy** C++ library?

	I'll have to port everything to JS from scratch? <!-- .element: class="fragment" --> 
	![Cat typing frantic](img/giphy.webp) <!-- .element: width="50%" -->

	Note:
	- GAMES: complex codebase, too much work to port to Web?
</textarea>
</section>

<section data-markdown>
<textarea data-template>
	What if we just want to...

	```
	$> mycompilercc my_c_code.cpp -o c_compiled_to_js.js
	```

	![Yes we can](img/yes-we-can.gif) <!-- .element: class="fragment" -->

	Emscripten (open source) <!-- .element: class="fragment" --> 

	Mandreel (closed source) <!-- .element: class="fragment" --> 
</textarea>
</section>

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	<svg id="timeline-emscripten" height="180" width="100%">
		<image x="0" y="0" width="100%" height="300" xlink:href="img/timeline.svg" clip-path="inset(0 85% 0 0)"></image>
	</svg>

	Emscripten / Mandreel projects converged to same patterns of JS for compiled C++ code, involving: <!-- .element: class="fragment" --> 
	- <!-- .element: class="fragment" --> Singleton typed array as **memory heap**
	- <!-- .element: class="fragment" --> Bitwise operations (`|0`, etc) to force **statically typed values**

	Note:
	- JavaScript is dynamic/weak typed, interpreted language
	- complex types (e.g. strings) and objects are allocated on typed array (int32)
	- |0 forces variable to be 32-bit integer -- and this is optimized on JS engines and runs faster
</textarea>
</section>

<section data-markdown>
<textarea data-template>
	Emscripten / Mandreel code could run quickly!

	...but there were still some gap between it and native code. <!-- .element: class="fragment" -->

	So Mozilla began a open-source project to investigate how to narrow this gap. <!-- .element: class="fragment" -->

	Emscripten / Mandreel pattern got formally defined as a type system, called <!-- .element: class="fragment" -->

	# asm.js <!-- .element: class="fragment" -->
</textarea>
</section>

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	<svg id="timeline2-asmjs" height="180" width="100%">
		<image x="0" y="0" width="100%" height="300" xlink:href="img/timeline.svg" clip-path="inset(0 68% 0 0)"></image>
	</svg>

	## asm.js

	- <!-- .element: class="fragment" --> A strict subset of JavaScript 

	- <!-- .element: class="fragment" --> Uses low-level CPU operations instead of more expensive JS code

	- <!-- .element: class="fragment" --> Additional optimizations were made on JS engines to make asm.js even faster

	Note:
	- Strict subset: 1) typed array as memory heap 2) bitwise operations for statically-typed vars
	- asm.js is not a new technology/language. It's more like a pattern for compiled code in JavaScript.
	- asm.js is not a new VM. No new VM or JIT was written, just additional optimizations to existing JS VMs.

</textarea>
</section>

<section data-markdown data-template>
	**asm.js** is *not* designed for humans!

	**asm.js** was designed primarily as a **compiler target**
</section>

<section data-markdown>
<textarea data-template data-separator-notes="^Note:">
	```c
	// C code
	size_t strlen(char *ptr) {
	  char *curr = ptr;
	  while (*curr != 0) {
	    curr++;
	  }
	  return (curr - ptr);
	}
	```

	<p class="fragment">**C/C++** => clang => **LLVM IR** => Emscripten => **asm.js**</p>


	```javascript 
	// asm.js - C compiled as JavaScript
	function strlen(ptr) {
	  ptr = ptr|0;
	  var curr = 0;
	  curr = ptr;
	  while (MEM8[curr]|0 != 0) {
	    curr = (curr + 1)|0;
	  }
	  return (curr - ptr)|0;
	}
	```
	<!-- .element: class="fragment" --> 

	Note:
	- LLVM generates a IR (intermediate representation)
	- complex types (e.g. strings) and objects are allocated on typed array (int32)
	- |0 forces variable to be 32-bit integer -- and this is optimized on JS engines and runs faster
</textarea>
</section>

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	```javascript
	// asm.js - C compiled as JavaScript
	function strlen(ptr) {
	  ptr = ptr|0;
	  var curr = 0;
	  curr = ptr;
	  while (MEM8[curr]|0 != 0) {
	    curr = (curr + 1)|0;
	  }
	  return (curr - ptr)|0;
	}
	```

	asm.js benefits from JavaScript engines optimizations:
	
	- <!-- .element: class="fragment" --> `ptr` is implicitly typed as a integer - preventing engine **infer types** 
	- <!-- .element: class="fragment" --> Read integer from address `curr` - engines optimizes **typed arrays** very well

	Note:
	- bitwise operators (e.g. |0) convert operands to 32-bit signed integer
	- MEM8 is the "heap" of asm.js code
	- fixed types - only i32 i64 f32 f64
	- asm.js code does only low-level assembly-like computation -- hence the name (asm is the abbreviation for assembly)

</textarea>
</section>

<section data-markdown>
<textarea data-template>
	But asm.js have some drawbacks...

	- Syntax may result **large js file**
	- Needs to be **parsed**
	- Growing initial heap is **expensive**

	That's why community started developing... <!-- .element: class="fragment" -->

	# WebAssembly <!-- .element: class="fragment" -->

	a.k.a. wasm <!-- .element: class="fragment" -->

	Note:
	- developed in a W3C Community Group
	- colab major browsers: Firefox (Mozilla), Chrome (Google), Safari (Apple), Edge (Microsoft)
</textarea>
</section>

<section>
	<svg id="timeline3-wasm-announ" height="180" width="100%">
		<image x="0" y="0" width="100%" height="300" xlink:href="img/timeline.svg" clip-path="inset(0 48% 0 0)"></image>
	</svg>
</section>

<section>
	<svg id="timeline4-browsers" height="180" width="100%">
		<image x="0" y="0" width="100%" height="300" xlink:href="img/timeline.svg" clip-path="inset(0 32% 0 0)"></image>
	</svg>

	<aside class="notes">
	<ul><li>Adobe, AutoDesk, Epic, Facebook, Mega, Unity, and more shipping with Emscripten/asm.js</li></ul>
</section>

<section>
	<svg id="timeline5-mvp" height="180" width="100%">
		<image x="0" y="0" width="100%" height="300" xlink:href="img/timeline.svg" clip-path="inset(0 18% 0 0)"></image>
	</svg>
</section>

<section>
	<svg id="timeline6-w3c" height="180" width="100%">
		<image x="0" y="0" width="100%" height="300" xlink:href="img/timeline.svg" clip-path="inset(0 0% 0 0)"></image>
	</svg>
</section>

<section data-markdown>
<textarea data-template>
	## WebAssembly

	- Binary format
	- Size- and load-time-efficient
	- Memory-safe, sandboxed
	- Target for compilation of high-level code (e.g. C/C++/Rust) for the web
</textarea>
</section>

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	<span>WASM is **NOT** a *programming language* <small>(although you can write .wast)</small></span>

	<span>It is a **compilation target for the web**</span> <!-- .element: class="fragment highlight" --> 

	<br/>

	<span>WASM is **NOT** assembly or native code running on your machine (like Flash or Silverlight plugins)</span> <!-- .element: class="fragment" -->

	<span>It is instruction-level code running atop JS engine!</span> <!-- .element: class="fragment highlight" --> 

	Note:
	- It's NOT a VM within chrome
	- Pointers are not raw address
	- This means: security model of the web doesn't change
</textarea>
</section>

<section>
	<section data-markdown>
	<textarea data-template>
		Think of WebAssembly as a *binary encoding* of **asm.js** with *tweaks* to make it a better compiler target

		<span>**WebAssembly** = asm.js done right ✔️</span> <!-- .element: class="fragment highlight" --> 
	</textarea>
	</section>

	<section data-markdown data-template data-separator="^\n----\n" data-separator-vertical="^\n---\n">

|	asm.js			 	|  |	WebAssembly		|
|:---------------------:|  |:------------------:|
| `(x+y)⎮0`				|↦ | `i32.add`			|
| `f()⎮0`				|↦ | `call`				|
| `HEAP32[i>>2]⎮0`		|↦ | `i32.load`			|

	</section>
</section>

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	**Why WebAssembly is FAST?**

	<img src="./img/linclark-complete.png" style="width:50%; background:none; border:none; box-shadow: none;">

	- <!-- .element: class="fragment" --> wasm is **binary format** => small size fetches faster
	- <!-- .element: class="fragment" --> wasm is an **AST** (abstract syntax tree) => no parse, just decode
	- <!-- .element: class="fragment" --> less optimization, no reoptimization
	- <!-- .element: class="fragment" --> memory is managed manually => **no garbage collection**

	Note:
	- JS code parses to AST and are decoded to engine's bytecode -- wasm is already an AST.
	- wasm decode is much faster than js parse and decode.
	- opt: wasm is closer to engine's instruction / no need to type-checking
</textarea>
</section>

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	## WASM API concepts

	- <!-- .element: class="fragment" --> **Module** - a wasm binary compiled by the browser into executable 'JS machine code'

	- <!-- .element: class="fragment" --> **Memory** - a growable `ArrayBuffer` used as memory heap

	- <!-- .element: class="fragment" --> **Table** - an array to store function references

	- <!-- .element: class="fragment" --> **Instance** - a stateful, initialized module connected to both a memory and a table object

	Note:
	- Memory: C memory heap
</textarea>
</section>

<section data-markdown>
<textarea data-template>
	## How to load and execute WASM?

	```javascript
	// fetch wasm binary
	const bytes = await fetch('./foo.wasm')
	  .then(res => res.arrayBuffer());

	// compile module and instantiate
	const instance = await WebAssembly.instantiate(bytes)
	  .then(res => res.instance);

	// call exported function
	var ans = instance.exports.foo(bar)

	```
</textarea>
</section>

<section> <!-- addOne example starts here -->
	<section data-markdown>
		# "ADD ONE" EXAMPLE
	</section>

	<section data-markdown>
	<textarea data-template>
		```c
		// add_one.c
		int addOne (int i) {
		  return i + 1;
		}
		```
	</textarea>
	</section>

	<section data-markdown>
	<textarea data-template>
		```javascript
		// asm.js representation
		function addOne(i) {
		  i = i|0;
		  return (i + 1)|0;
		}
		```
	</textarea>
	</section>


	<section data-markdown data-separator-notes="^Note:">
	<textarea data-template>
		```
		// add_one.wast -- s-expression
		(module
		 (table 0 anyfunc)
		 (memory $0 1)
		 (export "memory" (memory $0))
		 (export "addOne" (func $addOne))
		 (func $addOne (; 0 ;) (param $0 i32) (result i32)
		  (i32.add
		   (get_local $0)
		   (i32.const 1)
		  )
		 )
		)
		```

		Note:
		- S-expressions are simple textual format for representing trees
	</textarea>
	</section>

	<section data-markdown>
	<textarea data-template>
		```
		// add_one.wasm
		0061 736d 0100 0000 0186 8080 8000 0160
		017f 017f 0382 8080 8000 0100 0484 8080
		8000 0170 0000 0583 8080 8000 0100 0106
		8180 8080 0000 0793 8080 8000 0206 6d65
		6d6f 7279 0200 0661 6464 4f6e 6500 000a
		8d80 8080 0001 8780 8080 0000 2000 4101
		6a0b 
		```
	</textarea>
	</section>

	<section>
		Let's load and run add_one.wasm in this page...

<pre><code>(async () => {
  const bytes = await fetch('wasm/add_one/add_one.wasm')
    .then(res => res.arrayBuffer());

  const { instance } = await WebAssembly.instantiate(bytes);

  let numbox = document.getElementById('wasm_number');
  let resbox = document.getElementById('wasm_result');
  
  let ans = instance.exports.addOne(numbox.value)
  resbox.innerHTML = 'The answer is ' + ans;
})();</code></pre>

		<input id="wasm_number" type="text"/>
		<button onclick="(async () => {
		  const bytes = await fetch('wasm/add_one/add_one.wasm')
		    .then(res => res.arrayBuffer());

		  const { instance } = await WebAssembly.instantiate(bytes);

		  let numbox = document.getElementById('wasm_number');
		  let resbox = document.getElementById('wasm_result');
		  
		  let ans = instance.exports.addOne(numbox.value);
		  resbox.innerHTML = 'The answer is ' + ans;
		})();">+ 1 =</button>

		<div id="wasm_result">
		</div>
	</section>

</section> <!-- addOne example ends here -->

<section data-markdown data-separator-notes="^Note:">
<textarea data-template>
	Most of real code won't be as simple as `addOne()` example.

	We need to manually handle memory heap, pointer allocation, function tables, etc..  <!-- .element: class="fragment" -->

	Note:
	- Not simple as addOne: the "thing" of WASM is to import legacy, big, complex libraries to JS.
</textarea>
</section>

<section data-markdown>
<textarea data-template>
	**Emscripten** makes work easier by default:
	- <!-- .element: class="fragment" --> generates glue code to compile and instante wasm
	- <!-- .element: class="fragment" --> generates interfaces to access functions (`ccall`, `cwrap`)
	- <!-- .element: class="fragment" --> manages memory heap (string or object returns)
	- <!-- .element: class="fragment" --> wraps everything in a Module object *(not a WebAssembly.Module)*
</textarea>
</section>

<section>

	<section data-markdown data-template>
		# HANDS-ON!
	</section>

	<section data-markdown>
	<textarea data-template>
		counter.c

		```c
		#include <stdio.h>
		#include <emscripten/emscripten.h>

		int counter = 0;

		EMSCRIPTEN_KEEPALIVE
		int count() {
		  return ++counter;
		}

		EMSCRIPTEN_KEEPALIVE
		void set_count(int n) {
		  counter = n;
		}
		```
		<!-- .element: style="font-size: 0.35em;" -->
	</textarea>
	</section>

	<section data-markdown>
	<textarea data-template>
		Compile with Emscripten

		```
		$ emcc -s EXTRA_EXPORTED_RUNTIME_METHODS="['ccall', 'cwrap']"
		    counter.c -o counter.js
		```

		That generates
		- binary wasm module code (`counter.wasm`) 
		- JS file with glue code (`counter.js`)
	</textarea>	
	</section>

	<section>
	<script src="./wasm/counter/load_counter.js"></script>

<pre style="font-size: 0.35em;"><code>// load_counter.js
const wasm_counter = './wasm/counter/counter.wasm';
const js_counter = './wasm/counter/counter.js'

function loadScriptAsync(url) {
  return new Promise(resolve => {
    var tag = document.createElement('script');
    tag.src = url;
    tag.onload = () => resolve();
    document.body.appendChild(tag);
  })
}

(async () => {
  var response = await fetch(wasm_counter);
  Module.wasmBinary = await response.arrayBuffer();
  
  loadScriptAsync(js_counter).then( () => {
    window.count = Module.cwrap('count', 'number', []);
    window.setCount = Module.cwrap('set_count', null, ['number']);
  });
})();</code></pre>

	<input id="wasm_number2" type="text"/>

	<button onclick="(() => {
		let numbox = document.getElementById('wasm_number2');
		let resbox = document.getElementById('wasm_result2');
		let ans = setCount(numbox.value);
		resbox.innerHTML = 'Counter is now ' + ans;
	})();">Set count</button>

	<button onclick="(() => {
	  let resbox = document.getElementById('wasm_result2');
	  let ans = count();
	  resbox.innerHTML = 'Counter is now ' + ans;
	})();">counter++</button>

	<br/>

	<div id="wasm_result2"></div>
	</section>
</section>

<section>
	<section data-markdown data-template>
		# LUA POC
	</section>
	<section>
		<p>NuGinga's Lua 5.1 compiled with Emscripten</p>
		<iframe data-src="./wasm/lua/" style="width: 90%; height: 90%;"></iframe>
	</section>
</section>

<section data-markdown data-template>
	## WebAssembly examples

	- GAME: [Tanks! (Unity / WebGL)](https://webassembly.org/demo/Tanks/)
	- GAME: [AngryBots (Unity / WebGL)](https://files.unity3d.com/jonas/AngryBots/)
	- GAME: [Funky Karts](https://www.funkykarts.rocks/demo.html)
	- GAME: [After the Flood](https://playcanv.as/e/p/44MRmJRU/)
	- App: [LaTeX Base](https://latexbase.com/d/38d83003-1f6d-4fcc-aefc-5f6061ebdfde)
	- App: [PSPDFKit](https://pspdfkit.com/blog/2017/webassembly-a-new-hope/)
	- Lib: [libxml2](http://syssgx.github.io/xml.js/)
	- Lib: [web-dsp](https://github.com/shamadee/web-dsp)
</section>

<section data-markdown data-template>
	## Cool resources

	- YOUTUBE: [WebAssembly: Under the hood with Mozilla](https://www.youtube.com/watch?v=o52_5qAJhNg)
	- YOUTUBE: [WebAssembly and the Death of Javascript](https://www.youtube.com/watch?v=pBYqen3B2gc)
	- TEXT: [WebAssembly Desmystified](https://floooh.github.io/2017/06/09/webassembly-demystified.html)
	- TEXT: [What asm.js is and what asm.js isn't](http://mozakai.blogspot.com/2013/06/what-asmjs-is-and-what-asmjs-isnt.html)
	- TUTORIAL: [An Introduction to WebAssembly](https://codelabs.developers.google.com/codelabs/web-assembly-intro/index.html#0)
</section>

<section data-markdown data-template>
	# WebAssembly + Javascript = 
</section>

<section data-background="./img/world_domination.gif" data-background-size="contain" data-background-opacity="0.2">
	<h1>JAVASCRIPT WORLD DOMINATION</h1>
</section>


<section data-markdown data-template>
	# Questions?
</section>

</div>
</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			Reveal.initialize({
				transition: 'fade',
				zoomKey: 'ctrl',
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true }
				]
			});
		</script>
	</body>
</html>
